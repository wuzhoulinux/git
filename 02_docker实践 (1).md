# 02_docker安装部署

# 1.国内源安装docker-ce

## 配置linux内核流量转发功能



## 配置清华、阿里源皆可

### 清华的



### 阿里的





## Docker 服务端版本







## 启动第一个容器





# 2.初体验docker玩法

## 镜像命令

### 搜索镜像



### 下载镜像





### 查看镜像列表



### 获取docker hub 可用镜像版本





### 运行镜像，生成容器（nginx容器）

```
1. 本地运行模式


2. 对外运行模式



```







# 3.一张图玩懂docker操作





# 4.docker镜像详解

一个完成的Docker镜像可以支撑容器的运行，镜像提供文件系统

```
```



## 内核与发行版

传统的虚拟机安装操作系统所提供的系统镜像，包含两部分：

Linux内核部分

```
```

而docker镜像是不包含内核的，只是下载了某个发行版部分。

```

```





## docker镜像定义（如何生成的镜像）



我们如果自定义镜像，刚才超哥已经和大家说了，docker镜像不包含linux内核，和宿主机共用。

我们如果想要定义一个mysql5.6镜像，我们会这么做

- 获取基础镜像，选择一个发行版平台（ubutu，centos）
- 在centos镜像中安装mysql5.6软件

导出镜像，可以命名为mysql:5.6镜像文件。

从这个过程，我们可以感觉出这是一层一层的添加的，docker镜像的层级概念就出来了，底层是centos镜像，上层是mysql镜像，centos镜像层属于父镜像。





### 为什么要有docker镜像

其实就是将业务代码运行的环境，整体打包为单个的文件，就是docker镜像。

### 如何创建docker镜像

现在docker官方共有仓库里面有大量的镜像，所以最基础的镜像，我们可以在公有仓库直接拉取，因为这些镜像都是原厂维护，可以得到即使的更新和修护。

### dockerfile

我们如果想去定制这些镜像，我们可以去编写Dockerfile，然后重新bulid，最后把它打包成一个镜像

这种方式是最为推荐的方式包括我们以后去企业当中去实践应用的时候也是推荐这种方式。



### docker commit

当然还有另外一种方式，就是通过镜像启动一个容器，然后进行操作，最终通过commit这个命令commit一个镜像。



## docker镜像分层结构

```
可以基于 docker history 查看镜像每一层信息
[root@docker-01 ~]#docker history nginx:1.17.9 
```







## base镜像

base镜像是指如各种Linux发行版，如centos，ubuntu，Debian，alpine等。





## docker为什么分层镜像

```
例如在后面的docker优化篇有一个多阶段构建镜像

镜像1 ，centos7.9 基础镜像，我们可以在这里做环境基础配置，如yum源，防火墙，主机名，dns设置等

镜像2，以这个为基础，再构建如nginx环境，然后提交，这就是一个独立的nginx+centos的镜像。


镜像3，例如再多阶段，构建一个php-fpm镜像，以镜像2为base image，这样我们就构建了一个centos+nginx+php的镜像，并且这仨，只用同一份基础镜像，每个阶段只是额外加了一层而已。

镜像4 ，该优化手段，可以实现，任意的组合，每个阶段的镜像，都可以搭配其他环境使用，作为base image，或者叫父镜像。


因此docker镜像这种镜像分为一层一层的概念，实现的技术名字叫做 联合文件系统UnionFS。

```



镜像分享一大好处就是共享资源，例如有多个镜像都来自于同一个base镜像，那么在docker 主机只需要存储一份base镜像。

内存里也只需要加载一份base镜像，即可为多个容器服务。

> 即使多个容器共享一个base镜像，某个容器修改了base镜像的内容，例如修改/etc/下配置文件，其他容器的/etc/下内容是不会被修改的，修改动作只限制在单个容器内，这就是容器的写入时复制特性（Copy-on-write）。





# 5.docker镜像实践操作

## 镜像详细命令

```
1.获取镜像，docker hub里有大量高质量的镜像

2.查看所有镜像

3.docker本地镜像存储在宿主机的目录查看

# 基于docker info 查看 docker数据目录
docker info 


4.# 以基础镜像运行一个容器，添加参数
-i  Keep STDIN open even if not attached
-t  Allocate a pseudo-TTY 
--rm  Automatically remove the container when it exits
--name   Assign a name to the container
bash 指定容器运行什么



```



## 镜像增删改查管理



### none镜像

none镜像（dangline image 虚悬镜像）

出现none镜像的原因：

- 在docker hub上镜像如果更新后，名称变化，用户再docker pull就会出现该情况
- docker build时候，镜像名重复，也会导致新旧镜像同名，旧镜像名称被取消，出现none

```
1. 一般用docker tag解决即可
2. 或者提取docker id 删除none镜像
```





### 列出镜像

```
1.根据名字列出镜像

2.查看指定镜像

3.只查看镜像id，id就代表该镜像了

4.格式化输出docker信息

5.更丰富的格式化
[root@docker-01 ~]#docker images --format "table {{.ID}} {{.Repository}} {{.Tag}}"

6.格式化是docker信息提取的高级语法，需要学习下go的template语法
# 基于--format="{{json .}}" 拿到详细字段，即可格式化

[root@docker-01 ~]#docker images --format="{{json .}}"

[root@docker-01 ~]#docker images --format="{{.CreatedAt}} {{.ID}}  {{.Repository}} {{.Size}} {{.Tag}}" |column -t


```







### 删除本地镜像

```
# 删除镜像，可以用 ID，名字

# 删除镜像，要先干掉使用该镜像的容器（无论是否存活）


# 不加tag版本的话，默认latest


# 清理挂掉的容器实例记录


# 根据id删除（最短3位）


# 清理所有镜像（危险命令）
# 删除命令，包括了删除，以及取消tag两个步骤



# 提示，不要随便用 docker rmi -f 强制参数



```





### 导出、导入镜像

常用于公司的离线环境使用镜像

默认导出的是tar归档文件

```
导出镜像

导入镜像
# 环境清理

# 导入本地镜像


```



### 查看镜像详细信息

```
[root@docker-01 /images_save_all]#docker inspect nginx:1.17.9  | jq 

# 查看无论是镜像，还是容器的详细信息，都是维护容器的重要手段
```



# 6.docker容器管理实践

## 启动容器

`docker run`等于创建+启动

**注意：容器内的进程必须处于前台运行状态，否则容器就会直接退出**

我们运行如centos基础镜像，没有运行任何程序，因此容器直接挂掉

```
# 交互式的运行，可以进入容器空间


# 非交互式运行，容器会直接挂掉（一般用于测试让容器执行某个命令，或者将某个镜像当做一个调试环境，执行xxx命令）

# 查看容器历史记录


```





## 运行可以活着的容器

```
-d 对于宿主机，后台运行容器
-p 端口映射

# 直接访问宿主机即可

# 宿主机上访问容器ip也可以

# 提取容器ip

# 访问容器


# 运行容器且指定名字
```



## 停止容器（并非删除）

```
```



## 监控容器资源状态

```
```







## 进入容器空间

```
```



## 访问容器应用(redis)

由于我们做了端口映射，可以基于宿主机的端口访问



```
```



## 查看容器内日志

```
```







## 删除容器

```
```



## 查看容器记录（挂掉，运行中）

```
```



## 批量干掉容器进程

-q 只显示id

-a 显示所有记录



````
1. 下载mysql5.7.38镜像，确保可以远程访问，创建库表
2. 下载redis最新镜像，确保可以远程访问，读写key
3. 下载nginx 1.21.5 ，确保可以远程访问，修改首页内容为，"云原生！我来了！"
4. 下载wordpress最新镜像，运行，确保可以访问，发表文章。
````

